<?xml version="1.0" encoding="GB2312" ?>
<!--
	修改记录列表
	序号		修改类型		修改内容		修改人		修改日期
									孙峰								
-->
<!--
	测试点列表
	1.		
-->
<SQLTEST>
	<CONTENT> 该用例是针对数据对像类型而写的，主要难点是用LOOP来构造嵌套的各种语句 </CONTENT><!-- 请在这里加入对脚本的简要描述 -->
	<SQLSTR1></SQLSTR1>
	<SQLSTR1>24</SQLSTR1><!-- 如果想改动测试嵌套的层数，只要在这里面修改就可以了 -->
	<SQL_CASE><!-- 嵌套?层 -->
		<TYPE> DIRECT_EXECUTE_IGNORE </TYPE>
		<SQL> DROP TABLE OBJTYPE_T_010003 </SQL>	

		<LOOP>
			<NOSHOW></NOSHOW>
			<TIMES>@SQLSTR1</TIMES>
			<STARTTIMES>-1</STARTTIMES><!-- 从OBJTYPE_010003_24开始往下删，因为嵌套的时候是从小住大套的 -->
			<SQL> DROP TYPE OBJTYPE_010003_@TIMES </SQL>			
		</LOOP>
		<TYPE> DIRECT_EXECUTE_SUCCESS </TYPE>
		<SQL> CREATE TYPE OBJTYPE_010003_1 AS OBJECT(A INT, B INT); </SQL><!-- 最低层的对像类型 -->
		<SQLSTR></SQLSTR><!-- 清空原来保存的值 -->
		<SQLSTR>1</SQLSTR><!-- 初努化最底层的计数为1 -->
		<LOOP>
			<TIMES>@SQLSTR1</TIMES>
			<STARTTIMES>2</STARTTIMES>
			<SQL> CREATE TYPE OBJTYPE_010003_@TIMES AS OBJECT(A OBJTYPE_010003_@SQLSTR, B INT) </SQL>
			<SQLSTR></SQLSTR><!-- 清空原来保存的值 -->
			<SQLSTR>@TIMES</SQLSTR><!-- 保存这一次的值，留给下一层套用 -->						
		</LOOP>
		<SQL> CREATE TABLE OBJTYPE_T_010003(C OBJTYPE_010003_@SQLSTR1) </SQL>
		<!-- 插入一行试下 -->
		<SQLSTR></SQLSTR><!-- 清空原来保存的值 -->		
		<TEMPSTR></TEMPSTR><!-- 清空原来保存的值 -->
		<TEMPSTR>INSERT INTO OBJTYPE_T_010003(C) VALUES(@TEMPSTR)</TEMPSTR>
		<SQLSTR>@TEMPSTR</SQLSTR>
		<LOOP><!-- 构造插入语句 -->
			<TIMES>@SQLSTR1</TIMES>
			<STARTTIMES>-1</STARTTIMES><!-- 从OBJTYPE_010003_24开始往下套 -->
			<TEMPSTR></TEMPSTR><!-- 清空原来保存的值 -->
			<TEMPSTR>OBJTYPE_010003_@TIMES(@TEMPSTR, @TIMES)</TEMPSTR><!-- 清空原来保存的值 -->
			<SQLSTR>@</SQLSTR><!-- 在内部执行一次替代 -->		
		</LOOP>
		<TEMPSTR></TEMPSTR><!-- 清空原来保存的值 -->
		<TEMPSTR>100</TEMPSTR><!-- 清空原来保存的值 -->
		<SQLSTR>@</SQLSTR><!-- 在内部执行一次替代 -->
		<SQL>@SQLSTR</SQL>
		
		
		
		<!-- 构造查询语句验证插入的行 -->
		<SQLSTR></SQLSTR><!-- 清空原来保存的值 -->
		<SQLSTR>SELECT S.C</SQLSTR><!-- 验证最低层的A属性 -->
		<LOOP><!-- 构造查询语句 -->
			<TIMES>@SQLSTR1</TIMES>
			<SQLSTR>.A</SQLSTR>
		</LOOP>
		<TYPE> DIRECT_EXECUTE_SELECT_COMPARE_RESULT </TYPE><!-- 预期执行成功，并返回一个结果集，只验证给定值的长度 -->
		<SQL> @SQLSTR FROM OBJTYPE_T_010003 S </SQL>
		<RESULT>
			<RECORD>
				<COLUMN>100</COLUMN>
			</RECORD>
		</RESULT>
		
		<SQLSTR></SQLSTR><!-- 清空原来保存的值 -->
		<SQLSTR> SELECT S.C.B </SQLSTR><!-- 验证各层的B属性 -->
		<LOOP>
			<TIMES>@SQLSTR1</TIMES>
			<STARTTIMES>2</STARTTIMES>
			<SQLSTR2></SQLSTR2>
			<SQLSTR2>S.C</SQLSTR2>
			<LOOP><!-- 构造查询语句 -->
				<TIMES><EXP>@ TIMES-1</EXP></TIMES>
				<SQLSTR2>.A</SQLSTR2>
			</LOOP>
			<SQLSTR>,@SQLSTR2.B</SQLSTR>
		</LOOP>
		
		<TYPE> DIRECT_EXECUTE_SELECT_COMPARE_RESULT </TYPE><!-- 预期执行成功，并返回一个结果集，只验证给定值的长度 -->
		<SQL> @SQLSTR FROM OBJTYPE_T_010003 S </SQL>
		<RESULT>
			<RECORD>
				<COLUMNNUMS>@SQLSTR1</COLUMNNUMS><COLUMN><EXP>@SQLSTR1-@COLUMNNUMS+1</EXP></COLUMN>
			</RECORD>
		</RESULT>
		
		
		<SQLSTR></SQLSTR><!-- 清空原来保存的值 -->
		<SQLSTR>SELECT S.C</SQLSTR>
		<LOOP>
			<TIMES>@SQLSTR1</TIMES>
			<STARTTIMES>-1</STARTTIMES><!-- 从OBJTYPE_010003_24开始往下套 -->
			<SQLSTR>.A</SQLSTR>	
		</LOOP>	
		<SQLSTR> FROM OBJTYPE_T_010003 S WHERE S.C</SQLSTR>
		<LOOP>
			<TIMES>@SQLSTR1</TIMES>
			<STARTTIMES>-1</STARTTIMES><!-- 从OBJTYPE_010003_24开始往下套 -->
			<SQLSTR>.A</SQLSTR>	
		</LOOP>
		<SQLSTR> = 100</SQLSTR><!-- A = 100 -->
		<SQL> @SQLSTR </SQL>
		<RESULT>
			<RECORD>
				<COLUMN>100</COLUMN>
			</RECORD>
		</RESULT>
		<SQLSTR>0</SQLSTR><!-- 原来语句上追加一个0，变成A = 1000，应该是空结果集 -->
		<SQL> @SQLSTR </SQL>
		<RESULT><!-- 空结果集 -->
		</RESULT>
		<!-- 下面验证列名 -->
		<TYPE> DIRECT_EXECUTE_SELECT_WITH_RESULT </TYPE><!-- 预期执行成功，并返回一个结果集，但不对它验证，只验证其返回的列名 -->
		<SQLSTR></SQLSTR><!-- 清空原来保存的值 -->
		<SQLSTR>C</SQLSTR>
		<LOOP>
			<TIMES>@SQLSTR1</TIMES>
			<STARTTIMES>-1</STARTTIMES><!-- 从OBJTYPE_010003_24开始往下套 -->
			<SQLSTR>.A</SQLSTR>	
		</LOOP>
		<SQL>SELECT S.@SQLSTR FROM OBJTYPE_T_010003 S</SQL>
		<RESULT>
			<RECORD>
				<COLUMN>@SQLSTR</COLUMN>
			</RECORD>
		</RESULT>
		<SQLSTR></SQLSTR><!-- 清空原来保存的值 -->
		<SQLSTR>C</SQLSTR>
		<LOOP>
			<TIMES>@SQLSTR1</TIMES>
			<STARTTIMES>2</STARTTIMES><!-- 从OBJTYPE_010003_24开始往下套 -->
			<SQLSTR>.A</SQLSTR>	
		</LOOP>
		<SQLSTR>.B</SQLSTR>
		<SQL>SELECT S.@SQLSTR FROM OBJTYPE_T_010003 S</SQL>
		<RESULT>
			<RECORD>
				<COLUMN>@SQLSTR</COLUMN>
			</RECORD>
		</RESULT>
		<TYPE> DIRECT_EXECUTE_FAIL </TYPE>
		<IF>BOOL:'@UID'='SYSTEM'</IF>
		<SQL> SELECT S.C FROM OBJTYPE_T_010003 S </SQL>	
	</SQL_CASE>	
	<!-- - - - - - - - - - - - 测试点1：结束 - - - - - - - - - - - -->
	<CONTENT> 验证建立包含多个属性和方法的对象类型 </CONTENT><!-- 请在这里加入对脚本的简要描述 -->
	<!-- +++++++++++++++++++++ 测试点1：开始 +++++++++++++++++++++ -->
	<SQL_CASE>
		<TYPE> DIRECT_EXECUTE_IGNORE </TYPE><!-- 清理上一次的运行环境 -->
		<SQL> DROP TABLE OBJTYPE_T_010003</SQL>	
		<LOOP>
			<NOSHOW></NOSHOW>
			<TIMES>@SQLSTR1</TIMES>
			<STARTTIMES>-1</STARTTIMES><!-- 从OBJTYPE_010003_24开始往下删，因为嵌套的时候是从小住大套的 -->
			<SQL> DROP TYPE OBJTYPE_010003_@TIMES </SQL>			
		</LOOP>
		<SQLSTR></SQLSTR>
		<SQLSTR> CREATE TYPE OBJTYPE_010003_1 AS OBJECT(A1 INT</SQLSTR>
		<LOOP><!-- 添加属性 -->
			<TIMES>@SQLSTR1</TIMES>
			<STARTTIMES>2</STARTTIMES><!-- 从2开始叠加 -->
			<SQLSTR> ,A@TIMES INT</SQLSTR>
		</LOOP>
		<LOOP><!-- 添加方法 -->
			<TIMES>@SQLSTR1</TIMES>
			<SQLSTR> ,MEMBER FUNCTION F@TIMES(A INT) RETURN INT </SQLSTR>
		</LOOP>
		<SQLSTR>)</SQLSTR>
		<TYPE> DIRECT_EXECUTE_SUCCESS </TYPE>
		<SQL> @SQLSTR </SQL>
		<SQLSTR></SQLSTR>
		<SQLSTR>CREATE TYPE BODY OBJTYPE_010003_1 AS MEMBER FUNCTION F1(A INT) RETURN INT AS BEGIN RETURN 1 END</SQLSTR>
		<LOOP><!-- 构造创建方法主体语句 -->
			<TIMES>@SQLSTR1</TIMES>
			<STARTTIMES>2</STARTTIMES><!-- 从2开始叠加 -->
			<SQLSTR> ;MEMBER FUNCTION F@TIMES(A INT) RETURN INT AS BEGIN RETURN @TIMES END </SQLSTR>			
		</LOOP>
		<SQLSTR> ;END; </SQLSTR>
		<SQL> @SQLSTR </SQL><!-- 创建方法主体 -->
		<!-- 建表测试对像类型 -->
		<SQL> CREATE TABLE OBJTYPE_T_010003 OF OBJTYPE_010003_1 </SQL>
		<SQLSTR></SQLSTR>
		<SQLSTR>INSERT INTO OBJTYPE_T_010003 VALUES(1</SQLSTR>
		<LOOP><!-- 构造插入语句 -->
			<TIMES>@SQLSTR1</TIMES>
			<STARTTIMES>2</STARTTIMES><!-- 从2开始叠加 -->
			<SQLSTR> ,@TIMES</SQLSTR>
		</LOOP>
		<SQLSTR>)</SQLSTR>
		<SQL> @SQLSTR </SQL>
		<!-- 查询验证 -->
		<LOOP>
			<TIMES>@SQLSTR1</TIMES>			
			<SQLSTR></SQLSTR>			
			<SQLSTR>SELECT A@TIMES FROM OBJTYPE_T_010003</SQLSTR>
			<TYPE> DIRECT_EXECUTE_SELECT_COMPARE_RESULT </TYPE><!--  对比结果集中的数据 -->
			<SQL> @SQLSTR </SQL>
			<RESULT>
				<RECORD>
					<COLUMN>@TIMES</COLUMN>
				</RECORD>
			</RESULT>
		</LOOP>
		<!-- 整个结果集验证 -->
		<TYPE> DIRECT_EXECUTE_SELECT_COMPARE_RESULT </TYPE>
		<SQL> SELECT * FROM OBJTYPE_T_010003 </SQL>
		<RESULT>
			<RECORD>
				<COLUMNNUMS>@SQLSTR1</COLUMNNUMS><COLUMN>@COLUMNNUMS</COLUMN>
			</RECORD>
		</RESULT>
		<!-- 验证所有属性名称 -->
		<TYPE> DIRECT_EXECUTE_SELECT_WITH_RESULT </TYPE><!-- 预期执行成功，并返回一个结果集，但不对它验证，只验证其返回的列名 -->
		<SQL> SELECT * FROM OBJTYPE_T_010003 </SQL>
		<RESULT>
			<RECORD>
				<COLUMNNUMS>@SQLSTR1</COLUMNNUMS><COLUMN>A@COLUMNNUMS</COLUMN>
			</RECORD>
		</RESULT>
	</SQL_CASE>

	<CLEAR><!-- 脚本清除模块，该关键字标识清除块开始 -->
		<SQL_CASE>
			<SQL> DROP TABLE OBJTYPE_T_010003 </SQL>	
			<LOOP>
				<NOSHOW></NOSHOW>
				<TIMES><EXP>@SQLSTR1</EXP></TIMES>
				<STARTTIMES>-1</STARTTIMES><!-- 从OBJTYPE_010003_24开始往下删，因为嵌套的时候是从小住大套的 -->
				<SQL> DROP TYPE OBJTYPE_010003_@TIMES </SQL>			
			</LOOP>
		</SQL_CASE>
	</CLEAR>
</SQLTEST> 